<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: scala | Zuchos.com]]></title>
  <link href="http://zuchos.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://zuchos.github.io/"/>
  <updated>2015-06-10T12:17:07+02:00</updated>
  <id>http://zuchos.github.io/</id>
  <author>
    <name><![CDATA[Łukasz Żuchowski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to write a publisher for akka-streams?]]></title>
    <link href="http://zuchos.github.io/blog/2015/05/23/how-to-write-a-subscriber-for-akka-streams/"/>
    <updated>2015-05-23T00:05:10+02:00</updated>
    <id>http://zuchos.github.io/blog/2015/05/23/how-to-write-a-subscriber-for-akka-streams</id>
    <content type="html"><![CDATA[<p>Recently I started using <em>akka-http</em> and what I was trying to achieve was to receive data from request, send response that the data were received successfully and then process it asynchronously. The other requirement was that the processing flow could be complicated in the future and some parts of it could be faster than other, so I decided to use <em>akka-streams</em> for that. I started with empty <em>akka-http</em> service:</p>

<p>{% codeblock SimpleService lang:scala <a href="https://github.com/Zuchos/akka-http-with-streams/tree/blogpost1/src/main/scala/pl/zuchos/example/NaiveGsServer.scala">https://github.com/Zuchos/akka-http-with-streams/tree/blogpost1/src/main/scala/pl/zuchos/example/NaiveGsServer.scala</a> %}</p>

<p>  trait SimpleService {</p>

<pre><code>implicit val system: ActorSystem
implicit def executor: ExecutionContextExecutor
implicit val materializer: FlowMaterializer

val routes = {
  path("hello") {
    get {
      complete("Hello World!")
    }
  }
}
</code></pre>

<p>  }</p>

<p>  object NaiveGsServer extends App with SimpleService {</p>

<pre><code>override implicit val system = ActorSystem()
override implicit val executor = system.dispatcher
override implicit val materializer = ActorFlowMaterializer()

val config = ConfigFactory.load()

Http().bindAndHandle(routes, config.getString("http.host"), config.getInt("http.port"))
</code></pre>

<p>  }
{% endcodeblock %}</p>

<!--more-->


<p>Now we want to add new route that will accept data from sender. For this purpose we are going to add it to the routing definition.</p>

<p>{% codeblock lang:scala routes <a href="https://github.com/Zuchos/akka-http-with-streams/tree/blogpost1/src/main/scala/pl/zuchos/example/NaiveGsServer.scala">https://github.com/Zuchos/akka-http-with-streams/tree/blogpost1/src/main/scala/pl/zuchos/example/NaiveGsServer.scala</a> %}
  val routes = {
    path(&ldquo;hello&rdquo;) {
      get {
        complete(&ldquo;Hello World!&rdquo;)
      }
    } ~
    path(&ldquo;data&rdquo;) {
      (post &amp; entity(as[String]) &amp; parameter(&lsquo;sender.as[String])) {
        (dataAsString, sender: String) =>
          complete {
            HttpResponse(StatusCodes.OK, entity = &ldquo;Data received&rdquo;)
          }
      }
    }
  }
{% endcodeblock %}</p>

<p>What is now missing is the Publisher that will publish data that came from http request into the akka-stream. To do that we need to define <code>DataPublisher</code>. It will be an implementation of <code>ActorPublisher</code> trait. It will be receiving data and then it will be publishing those to the next element in the flow.</p>

<p>{% codeblock lang:scala DataPublisher <a href="https://github.com/Zuchos/akka-http-with-streams/tree/blogpost1/src/main/scala/pl/zuchos/example/actors/FramePublisher.scala">https://github.com/Zuchos/akka-http-with-streams/tree/blogpost1/src/main/scala/pl/zuchos/example/actors/FramePublisher.scala</a> %}
  case class Data(sender: Option[String], body: String)</p>

<p>  class DataPublisher extends ActorPublisher[Data] {
    var queue: mutable.Queue[Data] = mutable.Queue()</p>

<pre><code>override def receive: Actor.Receive = {
    case Publish(s) =&gt; queue.enqueue(s)
    publishIfNeeded()
  case Request(cnt) =&gt;
    publishIfNeeded()
  case Cancel =&gt; context.stop(self)
  case _ =&gt;
}

def publishIfNeeded() = {
  while (queue.nonEmpty &amp;&amp; isActive &amp;&amp; totalDemand &gt; 0) {
    onNext(queue.dequeue())
  }
}
</code></pre>

<p>  }</p>

<p>  object DataPublisher {
    case class Publish(data: Data)
  }
{% endcodeblock %}</p>

<p>As you may see, the main method is <code>receive()</code> which is responsible for accepting the incoming data and responding on demand on data that is coming from subscribers.
The last thing is to define the processing flow.</p>

<p>{% codeblock lang:scala flow definition <a href="https://github.com/Zuchos/akka-http-with-streams/tree/blogpost1/src/main/scala/pl/zuchos/example/NaiveGsServer.scala">https://github.com/Zuchos/akka-http-with-streams/tree/blogpost1/src/main/scala/pl/zuchos/example/NaiveGsServer.scala</a> %}
  val dataPublisherRef = system.actorOf(Props[DataPublisher])
  val dataPublisher = ActorPublisher<a href="dataPublisherRef">Data</a></p>

<p>  Source(dataPublisher)
    .runForeach(
      (x: Data) =>
        println(s"Data from ${x.sender} are being processed: ${x.body}&ldquo;)
    )
    .onComplete(_ => system.shutdown())
{% endcodeblock %}  <br/>
and then publish the incoming data:</p>

<p>{% codeblock lang:scala publishing <a href="https://github.com/Zuchos/akka-http-with-streams/tree/blogpost1/src/main/scala/pl/zuchos/example/NaiveGsServer.scala">https://github.com/Zuchos/akka-http-with-streams/tree/blogpost1/src/main/scala/pl/zuchos/example/NaiveGsServer.scala</a> %}
  path(&ldquo;data&rdquo;) {
    (post &amp; entity(as[String]) &amp; parameter(&lsquo;sender.as[String])) {
    (dataAsString, sender: String) =>
        complete {
          dataPublisherRef ! Publish(Data(sender, dataAsString))
          HttpResponse(StatusCodes.OK, entity = &ldquo;Data received&rdquo;)
        }
    }
{% endcodeblock %}</p>

<p>Now your application is ready to process incoming data with akka-streams. You may find complete example on <a href="https://github.com/Zuchos/akka-http-with-steams">github</a></p>
]]></content>
  </entry>
  
</feed>
